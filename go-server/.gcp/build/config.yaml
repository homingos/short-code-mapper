steps:
  # Detecting branch
  - name: "alpine/git"
    id: detect-branch
    secretEnv: ["SSH_KEY"]
    entrypoint: "ash"
    args:
      - -c
      - |
        mkdir -p /root/.ssh
        echo "$$SSH_KEY" > /root/.ssh/id_rsa
        chmod 400 /root/.ssh/id_rsa
        ssh-keyscan github.com > /root/.ssh/known_hosts

        git fetch origin
        if [[ "$BRANCH_NAME" == hotfix-prod* ]]; then
          echo "HOTFIX_BRANCH=prod" >> /workspace/branch_flags.txt
        elif [[ "$BRANCH_NAME" == hotfix-qa* ]]; then
          echo "HOTFIX_BRANCH=qa" >> /workspace/branch_flags.txt
        else
          echo "HOTFIX_BRANCH=false" >> /workspace/branch_flags.txt
        fi
        echo "Current branch: $BRANCH_NAME"
        cat /workspace/branch_flags.txt

  - name: "alpine/git"
    id: check-commit-msg-and-merge
    secretEnv: ["SSH_KEY"]
    entrypoint: "ash"
    args:
      - -c
      - |
        mkdir -p /root/.ssh
        echo "$$SSH_KEY" > /root/.ssh/id_rsa
        chmod 400 /root/.ssh/id_rsa
        ssh-keyscan github.com > /root/.ssh/known_hosts

        git fetch --unshallow origin production || git fetch origin production
        git checkout production

        COMMIT_MSG=$(git log -1 --pretty=%B)
        echo "Last commit message: $$COMMIT_MSG"
        if [ "$$COMMIT_MSG" = "This signifies a hotfix deployment" ]; then
          echo "_HOTFIX_COMMIT=nonprod" >> /workspace/commit_flags.txt
        elif [ "$$COMMIT_MSG" = "This signifies a prod hotfix deployment" ]; then
          echo "_HOTFIX_COMMIT=prod" >> /workspace/commit_flags.txt
        else
          echo "_HOTFIX_COMMIT=false" >> /workspace/commit_flags.txt
        fi
        cat /workspace/commit_flags.txt

  - name: "alpine/git"
    secretEnv: ["SSH_KEY"]
    entrypoint: "ash"
    args:
      - -c
      - |
        mkdir -p /root/.ssh
        echo "$$SSH_KEY" >> /root/.ssh/id_rsa
        echo "$$SSH_KEY" >> /workspace/id_rsa
        chmod 400 /root/.ssh/id_rsa
        ssh-keyscan github.com > /root/.ssh/known_hosts
        git config --global --add url."git@github.com:".insteadOf "https://github.com/"
        git remote set-url origin git@github.com:homingos/$REPO_NAME.git
        git submodule update --init
        git lfs install
        git lfs pull

  - name: "alpine/git"
    id: check-diff
    secretEnv: ["SSH_KEY"]
    entrypoint: "ash"
    args:
      - -c
      - |
        mkdir -p /root/.ssh
        echo "$$SSH_KEY" > /root/.ssh/id_rsa
        chmod 400 /root/.ssh/id_rsa
        ssh-keyscan github.com > /root/.ssh/known_hosts

        git fetch --unshallow origin production || git fetch origin production
        git checkout production
        echo "Checking git diff inside the same repo..."
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        echo $$CHANGED_FILES

        TOTAL_CHANGES=$(echo "$$CHANGED_FILES" | wc -l)
        SKAFOLD_CONFIG_CHANGES=$(echo "$$CHANGED_FILES" | grep -c -e "^skaffold.yaml$" -e "^.gcp/build/config.yaml$")
        HOTFIX_BRANCH=$(cat /workspace/branch_flags.txt | cut -d= -f2)

        # Set _SKIP_BUILD flag
        if [ -z "$$CHANGED_FILES" ] && [  "$$HOTFIX_BRANCH" = "false" ]; then
          # Empty commit
          echo "_SKIP_BUILD=true" >> /workspace/skip_build.txt
        elif [ "$$TOTAL_CHANGES" -eq "$$SKAFOLD_CONFIG_CHANGES" ] && [  "$$HOTFIX_BRANCH" = "false" ]; then
          # Only skaffold.yaml or config.yaml changed (no other files)
          echo "_SKIP_BUILD=true" >> /workspace/skip_build.txt
        else
          # Other files changed (with or without skaffold/config changes)
          echo "_SKIP_BUILD=false" >> /workspace/skip_build.txt
        fi

        echo "Changed files: \"$$CHANGED_FILES\""
        echo "Hotfix branch: $$HOTFIX_BRANCH"
        echo "Total changes: $$TOTAL_CHANGES"
        echo "Skaffold/config changes: $$SKAFOLD_CONFIG_CHANGES"
  
  #Skip build if no changes
  - name: "gcr.io/cloud-builders/docker"
    entrypoint: "bash"
    args:
      - -c
      - |
        SKIP_BUILD=$(cat /workspace/skip_build.txt | cut -d= -f2)
        if [ "$$SKIP_BUILD" = "true" ]; then
          echo "Skipping image build due to skip-build flag"
        elif [ "$$HOTFIX_COMMIT" = "nonprod" ] || [ "$$HOTFIX_COMMIT" = "prod" ]; then
          echo "Skipping img build due to infra hotfix commit"
        else
          docker build -f .docker/Dockerfile -t asia-south1-docker.pkg.dev/$PROJECT_ID/homingos/$REPO_NAME:$COMMIT_SHA .
        fi

  - name: "gcr.io/cloud-builders/docker"
    entrypoint: "bash"
    args:
      - -c
      - |
        SKIP_BUILD=$(cat /workspace/skip_build.txt | cut -d= -f2)
        if [ "$$SKIP_BUILD" = "true" ] || [ "$$HOTFIX_COMMIT" = "prod" ] || [ "$$HOTFIX_COMMIT" = "nonprod" ]; then
          echo "Skipping image push step"
          exit 0
        fi
        docker push asia-south1-docker.pkg.dev/$PROJECT_ID/homingos/$REPO_NAME:$COMMIT_SHA

  - name: "alpine/git"
    secretEnv: ["SSH_KEY"]
    entrypoint: "ash"
    args:
      - -c
      - |
        mkdir -p /root/.ssh
        echo "$$SSH_KEY" > /root/.ssh/id_rsa
        chmod 400 /root/.ssh/id_rsa
        ssh-keyscan github.com > /root/.ssh/known_hosts
        git clone git@github.com:homingos/service-helm-values.git /workspace/helm
        cp -r /workspace/helm/$REPO_NAME/values /workspace/values
        cd /workspace/values
        ls
  
  #Get the latest image tag from artifact registry
  - name: "gcr.io/google.com/cloudsdktool/cloud-sdk"
    id: get-latest-image-tag
    entrypoint: "bash"
    args:
      - -c
      - |
        echo "Fetching the latest image tag from Artifact Registry..."
        _LATEST_IMAGE_TAG=$(gcloud artifacts docker images list asia-south1-docker.pkg.dev/$PROJECT_ID/homingos/$REPO_NAME --sort-by=~CREATE_TIME --limit=1 --format="value(tags[0])" --include-tags)
        echo $$_LATEST_IMAGE_TAG
        echo "_LATEST_IMAGE_TAG=$$_LATEST_IMAGE_TAG" >> /workspace/latest_image_tag.txt
        cat /workspace/latest_image_tag.txt
  
  #Use the latest image tag while creating cloud deploy release
  - name: "gcr.io/google.com/cloudsdktool/cloud-sdk"
    id: create-release
    entrypoint: "bash"
    args:
      - -c
      - |
        echo "Creating Cloud Deploy release..."
        _LATEST_IMAGE_TAG=$(cat /workspace/latest_image_tag.txt | cut -d= -f2)
        echo "Latest image tag: $$_LATEST_IMAGE_TAG"
        
        # Determine which pipeline to use
        _HOTFIX_COMMIT=$(cat /workspace/commit_flags.txt | cut -d= -f2)
        HOTFIX_BRANCH=$(cat /workspace/branch_flags.txt | cut -d= -f2)
        echo $$HOTFIX_BRANCH
        if [ "$$_HOTFIX_COMMIT" = "nonprod" ] || [  "$$HOTFIX_BRANCH" = "qa"  ]; then
          _PIPELINE_NAME="fi-hotfix-pipeline"
          echo "Hotfix commit detected. Using pipeline: $$_PIPELINE_NAME"
        elif [  "$$_HOTFIX_COMMIT" = "prod" ] || [  "$$HOTFIX_BRANCH" = "prod"  ]; then
          _PIPELINE_NAME="fi-hotfix-direct-prod-pipeline"
          echo "Using hotfix prod pipeline: $$_PIPELINE_NAME"
        else
          _PIPELINE_NAME="$_DEPLOYMENT_PIPELINE_NAME"
          echo "Using default pipeline: $$_PIPELINE_NAME"
        fi

        gcloud auth configure-docker asia-south1-docker.pkg.dev --quiet
        gcloud deploy releases create release-campaign-$SHORT_SHA \
        --region=asia-south1 \
        --delivery-pipeline=$$_PIPELINE_NAME \
        --annotations="triggered_by=cloudbuild" \
        --images=imageurl=asia-south1-docker.pkg.dev/$PROJECT_ID/homingos/$REPO_NAME:$$_LATEST_IMAGE_TAG

options:
  logging: CLOUD_LOGGING_ONLY
availableSecrets:
  secretManager:
    - versionName: projects/$PROJECT_ID/secrets/SSH_KEY/versions/latest
      env: "SSH_KEY"
      